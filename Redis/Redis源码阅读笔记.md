## 前言

### 第一章 简介
这次Redis源码阅读笔记是在学习黄健宏的[《Redis 设计与实现》](http://redisbook.com)一书以及他的[源码注释](https://github.com/huangz1990/redis-3.0-annotated)过程中记录的.
这本书是对 Redis 的大多数单机功能以及所有多机功能的实现原理进行了介绍， 展示了这些功能的核心数据结构以及关键的算法思想。
通过阅读这本书，可以快速、有效地了解 Redis 的内部构造以及运作机制。

本书由四个部分组成:
 - 《数据结构与对象》
 - 《单机数据库的实现》
 - 《多机数据库的实现》
 - 《独立功能的实现》

### 推荐阅读方法
![推荐阅读方法](https://github.com/lyk2655/lyk2655.github.io/raw/master/Redis/img/Redis_1.1.png)


##  第一部分 数据结构与对象
Redis 数据库里面的每个键值对（key-value pair）都是由对象（object）组成的：
其中， 数据库键总是一个字符串对象（string object）；
而数据库键的值则可以是字符串对象、 列表对象（list object）、 哈希对象（hash object）、 集合对象（set object）、 有序集合对象（sorted set object）这五种对象中的其中一种。

### 第二章 简单动态字符串(simple dynamic string，SDS)
Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。
在 Redis 里面， C 字符串只会作为字符串字面量（string literal）， 用在一些无须对字符串值进行修改的地方。

#### SDS定义
```C
/*
 * 类型别名，用于指向 sdshdr 的 buf 属性
 */
typedef char *sds;

/*
 * 保存字符串对象的结构
 */
struct sdshdr {
    
    // buf 中已占用空间的长度
    int len;

    // buf 中剩余可用空间的长度
    int free;

    // 数据空间
    char buf[];
};
````
![DSD结构图](https://github.com/lyk2655/lyk2655.github.io/raw/master/Redis/img/Redis_2.1.png)

#### SDS与C字符串的区别

| C 字符串	|  SDS|  原因 | 
| 获取字符串长度的复杂度为 O(N) 。	| 获取字符串长度的复杂度为 O(1) 。 |  因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 。 SDS 在 len 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。
| API 是不安全的，可能会造成缓冲区溢出。| 	API 是| 安全的，不会造成缓冲区溢出。 |  C 字符串不记录自身长度带来的另一个问题是容易因为忘记申请足够空间造成缓冲区溢出（buffer overflow），例如strcat()函数，SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。
| 修改字符串长度 N 次必然需要执行 N 次内存重分配。	修改字符串长度 N 次最多需要执行 N 次内存重分配。 | 因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作。为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 free 属性记录。通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。
| 只能保存文本数据。	| 可以保存文本或者二进制数据。 | C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。
| 可以使用所有 <string.h> 库中的函数。	| 可以使用一部分 <string.h> 库中的函数。 | 虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <string.h> 库定义的函数。


#### SDS API

| 函数	       | 作用	                                       |   时间复杂度
| sdsnew	    | 创建一个包含给定 C 字符串的 SDS 。	         |   O(N) ， N 为给定 C 字符串的长度。
| sdsempty	    | 创建一个不包含任何内容的空 SDS 。	 | O(1)
| sdsfree	    | 释放给定的 SDS 。  | 	O(1)
| sdslen	    | 返回 SDS 的已使用空间字节数。	 | 这个值可以通过读取 SDS 的 len 属性来直接获得， 复杂度为 O(1) 。
| sdsavail	    | 返回 SDS 的未使用空间字节数。	 | 这个值可以通过读取 SDS 的 free 属性来直接获得， 复杂度为 O(1) 。
| sdsdup	    | 创建一个给定 SDS 的副本（copy）。 | 	O(N) ， N 为给定 SDS 的长度。
| sdsclear	    | 清空 SDS 保存的字符串内容。 | 	因为惰性空间释放策略，复杂度为 O(1) 。
| sdscat	    | 将给定 C 字符串拼接到 SDS 字符串的末尾。 | 	O(N) ， N 为被拼接 C 字符串的长度。
| sdscatsds	    | 将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。 | 	O(N) ， N 为被拼接 SDS 字符串的长度。
| sdscpy	    | 将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。 | 	O(N) ， N 为被复制 C 字符串的长度。
| sdsgrowzero	| 用空字符将 SDS 扩展至给定长度。	 | O(N) ， N 为扩展新增的字节数。
| sdsrange	    | 保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。 | 	O(N) ， N 为被保留数据的字节数。
| sdstrim	    | 接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。	 | O(M*N) ， M 为 SDS 的长度， N 为给定 C 字符串的长度
| sdscmp	    | 对比两个 SDS 字符串是否相同。 | 	O(N) ， N 为两个 SDS 中较短的那个 SDS 的长度。




